# Тема 9. ООП на Python: концепции, принципы и примеры реализации
Отчет по Теме #9 выполнил(а):
- Смирнова Анна Евгеньевна
- ИВТ-22-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию_init(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

### Результат.
![Меню]()

## Лабораторная работа №2
Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

### Результат.
![Меню]()

## Лабораторная работа №3
Петя - начинающий программист и на занятиях ему сказали реализовать икапсу...что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу...что-то - это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вам необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.
### Результат.
![Меню]()

 
## Лабораторная работа №4
Вам прекрасно известно, что кошки И собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи "наследования” объяснить компьютеру что кошки и собаки - это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
### Результат.
![Меню]()

## Лабораторная работа №5
На разных языках здороваются по-разному, но суть остаётся одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры- ссылки вроде self.
### Результат.
![Меню]()

## Самостоятельная работа №1
Создать основной код по описанию классов и их содержимого (скрин 1), выполнить тест 1 Вызовите справку по садоводству  (скрин 2).
### Результат.
![Меню]()
## Выводы
1. Класс Tomato:
статическое свойство states, которое содержит различные стадии созревания помидоров. В конструкторе определяем динамические свойства _index (индекс помидора) и _state (начальное состояние помидора, которое устанавливается на "незрелый"). Метод grow переводит помидор на следующую стадию созревания, если он еще не достиг состояния "красный". Если помидор уже созрел, выводится соответствующее сообщение. Метод is_ripe проверяет, созрел ли помидор.
2. Класс TomatoBush:
Конструктор создает список объектов класса Tomato, представляющих куст с заданным количеством помидоров. Метод grow_all вызывает метод grow для каждого помидора в кусте, переводя их на следующую стадию созревания. Метод all_are_ripe проверяет, все ли помидоры в кусте достигли состояния "красный". Метод give_away_all очищает список помидоров после сбора урожая.
3.Класс Gardener:
Конструктор создает два динамических свойства: имя садовника и растение (объект класса TomatoBush). Метод work позволяет садовнику ухаживать за растением, вызывая метод grow_all. Метод harvest проверяет, все ли помидоры созрели. Если да, выводится сообщение о сборе урожая и список помидоров очищается; если нет — выводится сообщение о необходимости дальнейшего ухода. Статический метод knowledge_base выводит справочную информацию по садоводству.
  
## Самостоятельная работа №2
Создайте объекты классов TomatoBush и Gardener
### Результат.
![Меню]()
## Выводы
Вызываем статический метод knowledge_base, чтобы получить справочную информацию по садоводству. Это поможет пользователю лучше понять, как ухаживать за растениями.
  
## Самостоятельная работа №3
Используя объект класса Gardener, поухаживайте за кустом с помидорами
### Результат.
![Меню]()
## Выводы
Создаем объект TomatoBush с 5 помидорами и объект Gardener с именем "Alice". Этот тест инициализирует необходимые объекты для дальнейших действий.
  
## Самостоятельная работа №4
Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними.
### Результат.
![Меню]()
## Выводы
Садовник "Alice" ухаживает за кустом с помидорами, вызывая метод work. Это приводит к тому, что все помидоры начинают расти на следующую стадию созревания.
  
## Самостоятельная работа №5
Соберите урожай.
### Результат.
![Меню]()
## Выводы
Пытаемся собрать урожай, когда помидоры еще не дозрели. Этот тест демонстрирует, что метод harvest корректно обрабатывает ситуацию, когда не все помидоры готовы к сбору.
  

## Общие выводы по теме
Благодаря изучению темы "ООП на Python: концепции, принципы и примеры реализации" я узнала о важных принципах, которые позволяют создавать гибкие и масштабируемые программы. Понимание классов и объектов дало мне возможность организовывать код в логические модули. Я экспериментировала с динамическим изменением атрибутов экземпляров, что продемонстрировало мне, как легко можно адаптировать поведение объектов в зависимости от условий. Были повторены и дополнены в базе моих знаний темы наследования, инкапсуляции и полиморфизма. Была создана интересная игра про садоводство.
